#!/usr/bin/perl

my ($i, $j, $k, $l, $m, $n, $m1length, $oldline, $newline, $OldReadName, $OldReadOR, $NewReadName, $NewReadOR, @each, @eacholdline, @eachnewline, @saveOR, @ReadName, @ReadOR, @m1OR, @m1Count, @m1adj);
my $m1file = $ARGV[0];
my $intersectfile = $ARGV[1];
chomp $m1file;
chomp $samfile;

$i = 0;
open(FIN1, $m1file) or die "can not open file1\n"; # file1: list of ORs in colomn 1, m1 unadjusted read counts in column 2
while (<FIN1>) 
{
	chomp($_);
	@each = split(/\t/,$_);
	$m1OR[$i] = $each[0];
	$m1Count[$i] = $each[1];
	$m1adj[$i] = $each[1];
	$i++;
}
$m1length = $i-1;
close (FIN1);

open(FIN2, $intersectfile) or die "can not open file2\n"; # file2: long intersect file generated by intersectbed. read names in colomn 4, ORs the read mapped to in colomn 10. sorted by read names.
$oldline = <FIN2>; # read in 1 line to get started
chomp($oldline);
@eacholdline = split(/\t/,$oldline);
$OldReadName = $eacholdline[3];
$OldReadOR = $eacholdline[9];
$ReadNumber = 0;
$ReadName[$ReadNumber] = $OldReadName; #ReadName, ReadOR are for temporary storage of consecutive same read mapped to different OR. $ReadNumber is a count.
$ReadOR[$ReadNumber] = $OldReadOR;

while (<FIN2>) {
	chomp($_);
	$newline = $_;
	@eachnewline = split(/\t/,$newline);
	$NewReadName = $eachnewline[3];
	$NewReadOR = $eachnewline[9];
	if ($NewReadName eq $OldReadName ) {	# continue to read in the block with same read names.
		$ReadNumber++;
		$ReadName[$ReadNumber] = $NewReadName; #ReadName, ReadOR are for temporary storage of consecutive same read mapped to different OR. $ReadNumber is a count.
		$ReadOR[$ReadNumber] = $NewReadOR;
		next; #if found consecutive read names, store in ReadName, ReadOR. Then start reading a new line.
	}
#	print STDOUT "@ReadOR\n";
	if ($NewReadName ne $OldReadName) { #if consecutivity disrupted, start analyzing the previous consecutive reads.
#		print STDOUT "$OldReadName\t$NewReadName\t$ReadNumber\n";
		$m = 0;
		$sum = 0;
		for ($k=0;$k<=$ReadNumber;$k++) { # go through all consecutive reads (mapped to different ORs)
			for ($l=0;$l<=$m1length;$l++) { # check in the list of all ORs
				if ($m1OR[$l] eq $ReadOR[$k]) { #when found the OR this read mapped to in the list of all ORs,
#					$saveOR[$m] = $m1OR[$l]; # save this OR name
#					print STDOUT "$ReadName[$k]\t$saveOR[$m]\n";
					$m++; # count add 1
					$sum = $sum + $m1Count[$l];
				}
			}
		}
#		print STDOUT "$m\t$saveOR[$m-1]\n";
		for ($k=0;$k<=$ReadNumber;$k++) { #go through all the ORs this read mapped to
            for ($l=0;$l<=$m1length;$l++) { #go find this OR in the list of ORs
                if ($m1OR[$l] eq $ReadOR[$k]) {
                    if ($sum > 0) {	$m1adj[$l] = $m1adj[$l] + $m1Count[$l]/$sum; } #adjust - if unadjusted read counts are available
#					print STDOUT "$m1OR[$l]\t$m1adj[$l]\t@ReadOR\n";
                	if ($sum == 0) { $m1adj[$l] = $m1adj[$l] + 1/($ReadNumber+1); } #adjust -  if unadjusted read counts are all 0's 
#					print STDOUT "$m1OR[$l]\t$m1adj[$l]\t@ReadOR\n";
				}
        	}
		}
		$OldReadName = $NewReadName; #to start the new round, reset everything
		$OldReadOR = $NewReadOR;
		$ReadNumber = 0;
#		@saveOR = "";
		@ReadName = "";
		@ReadOR = "";
		$ReadName[0] = $OldReadName;
		$ReadOR[0] = $OldReadOR; 
	}
}
close (FIN2);

for ($n=0;$n<=$m1length;$n++) {
#   print STDOUT "$m1OR[$n]\t$m1Count[$n]\t$m1adj[$n]\n";
	print STDOUT "$m1OR[$n]\t$m1adj[$n]\n";
}

